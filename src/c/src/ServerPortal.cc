/*
 ** Copyright (C) 2013 Mellanox Technologies
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
 ** You may obtain a copy of the License at:
 **
 ** http://www.apache.org/licenses/LICENSE-2.0
 **
 ** Unless required by applicable law or agreed to in writing, software
 ** distributed under the License is distributed on an "AS IS" BASIS,
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 ** either express or implied. See the License for the specific language
 ** governing permissions and  limitations under the License.
 **
 */

#include "bullseye.h"
#include "Utils.h"
#include "ServerPortal.h"

#define MODULE_NAME		"ServerPortal"
#define SRVPORTAL_LOG_ERR(log_fmt, log_args...)  LOG_BY_MODULE(lsERROR, log_fmt, ##log_args)
#define SRVPORTAL_LOG_WARN(log_fmt, log_args...)  LOG_BY_MODULE(lsWARN, log_fmt, ##log_args)
#define SRVPORTAL_LOG_DBG(log_fmt, log_args...)  LOG_BY_MODULE(lsDEBUG, log_fmt, ##log_args)

ServerPortal::ServerPortal(const char *url, long ptrCtx) {
	SRVPORTAL_LOG_DBG("CTOR start");

	flag_to_delete = false;

	struct xio_session_ops server_ops;
	memset(&server_ops, 0, sizeof(server_ops));
	server_ops.on_new_session = on_new_session_callback;
	server_ops.on_session_event = on_session_event_callback_server;
	server_ops.on_msg = on_msg_callback_server;
	server_ops.on_msg_send_complete = on_msg_send_complete_callback;
	server_ops.assign_data_in_buf = on_buffer_request_callback;
	server_ops.on_msg_error = on_msg_error_callback_server;

	struct xio_context *ctx;
	Context *ctxClass = (Context *) ptrCtx;
	this->ctx_class = ctxClass;
	this->is_closing = false;
	this->sessions = 0;

	this->server = xio_bind(ctxClass->get_xio_context(), &server_ops, url,
			&this->port, 0, this);
	BULLSEYE_EXCLUDE_BLOCK_START
	if (this->server == NULL) {
		SRVPORTAL_LOG_DBG("ERROR in binding server (errno=%d '%s')",
				xio_errno(), xio_strerror(xio_errno()));
		throw std::bad_alloc();
	}
BULLSEYE_EXCLUDE_BLOCK_END
		SRVPORTAL_LOG_DBG("CTOR done (on port=%d)", this->port);
}

ServerPortal::~ServerPortal() {
	BULLSEYE_EXCLUDE_BLOCK_START
	if (xio_unbind(this->server)) {
		SRVPORTAL_LOG_ERR("ERROR in xio_unbind server (errno=%d '%s')",
				xio_errno(), xio_strerror(xio_errno()));
	}
BULLSEYE_EXCLUDE_BLOCK_END
		SRVPORTAL_LOG_DBG("DTOR done");
}

void ServerPortal::deleteObject() {
	this->writeEventAndDelete();
}

void ServerPortal::writeEventAndDelete(bool force_scheduled /*=false*/) {
	Context* ctx = this->get_ctx_class();
	char* buf = ctx->get_buffer(force_scheduled);
	struct xio_session_event_data event_data;
	event_data.event = static_cast<xio_session_event>(2); // PORTAL_CLOSED
	event_data.reason = static_cast<xio_status>(XIO_E_SUCCESS);
	int sizeWritten = ctx->events.writeOnSessionErrorEvent(buf, this,
			&event_data);
	ctx->done_event_creating(sizeWritten);

	delete this;
}

void ServerPortal::scheduleWriteEventAndDelete() {
	//event generated by JXIO level(as opposed to other events that are generated by Accelio level)
	writeEventAndDelete(true);
}

void ServerPortal::writeEventForwardCompleted(ServerSession* ses) {
	Context *ctx = ses->get_ctx_forwarder();
	char* buf = ctx->get_buffer(false);
	struct xio_session_event_data event_data;
	event_data.event = static_cast<xio_session_event>(10); // FORWARD_COMPLETED
	event_data.reason = static_cast<xio_status>(XIO_E_SUCCESS);
	int sizeWritten = ctx->events.writeOnSessionErrorEvent(buf, ses,
			&event_data);
	ctx->done_event_creating(sizeWritten);
}

Context* ServerPortal::ctxForSessionEvent(struct xio_session_event_data * event,
		ServerSession* ses) {
	Context* ctx = NULL;
	xio_session* session = ses->get_xio_session();
	switch (event->event) {
	case XIO_SESSION_CONNECTION_CLOSED_EVENT: //event created because user on this side called "close"
		SRVPORTAL_LOG_DBG(
				"got XIO_SESSION_CONNECTION_CLOSED_EVENT in session %p. Reason=%s",
				session, xio_strerror(event->reason));
		//no need to delete session from map since we haven't received session_teardown yet
		if (ses->is_reject() || ses->ignore_disconnect(this))
			return NULL;
		ses->set_is_closing(true);
		return this->get_ctx_class();

	case XIO_SESSION_CONNECTION_TEARDOWN_EVENT:
		SRVPORTAL_LOG_DBG(
				"got XIO_SESSION_CONNECTION_TEARDOWN_EVENT in session %p. Reason=%s",
				session, xio_strerror(event->reason));
		if (ses->is_reject()) {
			xio_connection_destroy(event->conn);
			return NULL;
		}
		//there was a forward and this is the initial connection
		if (ses->ignore_disconnect(this)) {
			SRVPORTAL_LOG_DBG(
					"got final event for leading connection in case of forward for server session %p",
					ses);
			//this is java internal event
			writeEventForwardCompleted(ses);
			xio_connection_destroy(event->conn);
			return NULL;
		}
		return this->get_ctx_class();

	case XIO_SESSION_NEW_CONNECTION_EVENT:
		SRVPORTAL_LOG_DBG("got XIO_SESSION_NEW_CONNECTION_EVENT in session %p",
				session);
		ses->set_xio_connection(event->conn, this);
		struct xio_connection_attr conn_attr;
		conn_attr.user_context = ses;
		BULLSEYE_EXCLUDE_BLOCK_START
		if (xio_modify_connection(event->conn, &conn_attr,
				XIO_CONNECTION_ATTR_USER_CTX)) {
			LOG_ERR("xio_modify_connection for session=%p failed", session);
		}
BULLSEYE_EXCLUDE_BLOCK_END
				LOG_DBG("xio_modify_connection for session=%p to %p", session, ses);

		return NULL;

	case XIO_SESSION_CONNECTION_DISCONNECTED_EVENT: //event created "from underneath"
		SRVPORTAL_LOG_DBG(
				"got XIO_SESSION_CONNECTION_DISCONNECTED_EVENT in session %p. Reason=%s",
				session, xio_strerror(event->reason));
		//no need to delete session from map since we haven't received session_teardown yet
		if (!ses->ignore_disconnect(this)) {
			ses->set_is_closing(true);
		}
		return NULL;

	case XIO_SESSION_TEARDOWN_EVENT:
		SRVPORTAL_LOG_DBG("got XIO_SESSION_TEARDOWN_EVENT in session %p",
				session);
		//the event should also be written to buffer to let user know that the session was closed
		BULLSEYE_EXCLUDE_BLOCK_START
		if (xio_session_destroy(session)) {
			SRVPORTAL_LOG_ERR("Error in xio_session_close: '%s' (%d)",
					xio_strerror(xio_errno()), xio_errno());
		}
		BULLSEYE_EXCLUDE_BLOCK_END
		//last event for this session EVER: ses can be deleted from the map, but not deleted
		//this teardown is after user did reject. He does not need to get this event
		if (ses->delete_after_teardown) {
			delete ses;
			return NULL;
		}
		this->sessions--;
		if (this->is_closing && this->sessions == 0) {
			//once the portal is marked for closing it should be deleted once no more sessions are listening on it
			SRVPORTAL_LOG_DBG(
					"there aren't any sessions on this server anymore. Can close");
			flag_to_delete = true;
		}
		return this->get_ctx_class();

	case XIO_SESSION_CONNECTION_ERROR_EVENT:
		SRVPORTAL_LOG_DBG(
				"got XIO_SESSION_CONNECTION_ERROR_EVENT in session %p. Reason=%s",
				session, xio_strerror(event->reason));
		return NULL;

	BULLSEYE_EXCLUDE_BLOCK_START
	default:
		SRVPORTAL_LOG_WARN("UNHANDLED event in session %p: got event '%s' (%d)",
				session, xio_session_event_str(event->event), event->event);
		ses->set_is_closing(true);
		return this->get_ctx_class();
	BULLSEYE_EXCLUDE_BLOCK_END
}
}
